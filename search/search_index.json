{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Literate Programming with Entangled, Gitpod and MkDocs \u00b6 This repository is a template to create beautiful literate programs with Entangled and Mkdocs. In order to make it easier to start writing your documentation this also runs as a Gitpod instance. So you only need to fork this repository and open it on gitpod: https://gitpod.io/#prebuild/ And you can start write your documentation right away. Now this is also a literate programming environment. Using https://entangled.github.io. That means that code fragments you write in your makrdown files get extracted automatically and exposed as files. Take a look at 'docs/index.md' to learn how the dockerfile that allows this project to be executed in GitPod get's generated. And the continuous integration github action.","title":"Home"},{"location":"#literate-programming-with-entangled-gitpod-and-mkdocs","text":"This repository is a template to create beautiful literate programs with Entangled and Mkdocs. In order to make it easier to start writing your documentation this also runs as a Gitpod instance. So you only need to fork this repository and open it on gitpod: https://gitpod.io/#prebuild/ And you can start write your documentation right away. Now this is also a literate programming environment. Using https://entangled.github.io. That means that code fragments you write in your makrdown files get extracted automatically and exposed as files. Take a look at 'docs/index.md' to learn how the dockerfile that allows this project to be executed in GitPod get's generated. And the continuous integration github action.","title":"Literate Programming with Entangled, Gitpod and MkDocs"},{"location":"about/","text":"About \u00b6 Entangled helps you write Literate Programs in Mardown. You put all your code inside Markdown code blocks. Entangled automatically extracts the code and writes it to more traditional source files. You can then edit these generated files, and the changes are being fed back to the Markdown. We're trying to increase the visibility of Entangled. If you like Entangled, please consider adding this badge to the appropriate location in your project: [![Entangled badge](https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff)](https://entangled.github.io/)","title":"About"},{"location":"about/#about","text":"Entangled helps you write Literate Programs in Mardown. You put all your code inside Markdown code blocks. Entangled automatically extracts the code and writes it to more traditional source files. You can then edit these generated files, and the changes are being fed back to the Markdown. We're trying to increase the visibility of Entangled. If you like Entangled, please consider adding this badge to the appropriate location in your project: [![Entangled badge](https://img.shields.io/badge/entangled-Use%20the%20source!-%2300aeff)](https://entangled.github.io/)","title":"About"},{"location":"deployment/","text":"Continuouns Integration \u00b6 When we making any commit in this repository we want to autamically take the literate programming documents in 'docs' and extract the code from them (tangle) and update the website where they are exposed (weaving). To achive that automatation we are going to use GitHub actions. Basic structure of a GitHubAction \u00b6 I took this material from mkdocs-material Using [GitHub Actions] you can automate the deployment of your project documentation. At the root of your repository, create a new GitHub Actions workflow, e.g. .github/workflows/ci.yml , and copy and paste the following contents: file://.github/workflows/ci.yml name : ci # (1)! on : push : branches : # (2)! - master jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.x <<tangle_code_files>> <<weave_mkdocs_site>> You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ... Tangle \u00b6 We first need to generate all the code files from the literate markdown files. In order to do that we will entangled. #tangle_code_files - run : pip install entangled-filters - run : wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ - run : entangled tangle -a Weaving \u00b6 Is the process of taking the literate markdown files and generating a beautiful website for humans to consume #weave_mkdocs_site - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force","title":"Deployment"},{"location":"deployment/#continuouns-integration","text":"When we making any commit in this repository we want to autamically take the literate programming documents in 'docs' and extract the code from them (tangle) and update the website where they are exposed (weaving). To achive that automatation we are going to use GitHub actions.","title":"Continuouns Integration"},{"location":"deployment/#basic-structure-of-a-githubaction","text":"I took this material from mkdocs-material Using [GitHub Actions] you can automate the deployment of your project documentation. At the root of your repository, create a new GitHub Actions workflow, e.g. .github/workflows/ci.yml , and copy and paste the following contents: file://.github/workflows/ci.yml name : ci # (1)! on : push : branches : # (2)! - master jobs : deploy : runs-on : ubuntu-latest steps : - uses : actions/checkout@v2 - uses : actions/setup-python@v2 with : python-version : 3.x <<tangle_code_files>> <<weave_mkdocs_site>> You can change the name to your liking. At some point, GitHub renamed master to main . If your default branch is named master , you can safely remove main , vice versa. This is the place to install further [MkDocs plugins] or Markdown extensions with pip to be used during the build: pip install \\ mkdocs-material \\ mkdocs-awesome-pages-plugin \\ ...","title":"Basic structure of a GitHubAction"},{"location":"deployment/#tangle","text":"We first need to generate all the code files from the literate markdown files. In order to do that we will entangled. #tangle_code_files - run : pip install entangled-filters - run : wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ - run : entangled tangle -a","title":"Tangle"},{"location":"deployment/#weaving","text":"Is the process of taking the literate markdown files and generating a beautiful website for humans to consume #weave_mkdocs_site - run : pip install mkdocs-material # (3)! - run : mkdocs gh-deploy --force","title":"Weaving"},{"location":"doc_rot/","text":"Software rot \u00b6 Is a slow deterioration of software quality over time or its diminishing responsiveness that will eventually lead to software becoming faulty, unusable, or in need of upgrade. This is not a physical phenomenon: the software does not actually decay, but rather suffers from a lack of being responsive and updated with respect to the changing environment in which it resides. Documentation rot is \u00b6 when your documentation stops working because the environment (programs, operating systems, libraries) has changed. For example \u00b6 As Tech writer \u00b6 You write a tutorial and in the beginning everybody is happy with it. The explanations and the step by step instructions work well. However in just a few months and in the case of new techology even in a few days the tutorial doesn't work anymore frustrating new users and the writer. How can we avoid this destiny? Literate programming \u00b6 Is a programming paradigm in which the main goal is to write document, that explains to other humans the intentions of your code. By writing a book / article intertwined with code. Then the code is separated in an operation named Tangle And the article is prepared for publication in an operation called weaving Elments of a software tutorial \u00b6 Description of the software Installation and setup Prerequisites Installation Configuration (if needed) Basic example Example input step by step instructions that the user should perform Expected output Conclusion and next steps Given that I present a (basic tutorial to use pandoc)[../pandoc/] A basic tutorial example \u00b6 Clarity is not enough \u00b6 Our tutorial is very, simple and easy to follow. But that is not enough, we also need correctness The instructions that we indicate the user should actually and reliably work. So to do that we need to convert our tutorial into a script ... A Clear, Correct tutorial is not enough... \u00b6 Our tutorial is clearly explained and we know that the instructions we provide the user are correct. Now we need to make sure, that the tutorial remains correct. So we need to monitor the environment on which our tutorial is still working How to solve it. \u00b6 Let's look at a very simple tutorial, even a README \u00b6 A typical tutorial includes the following sections: Example for a tutorial \u00b6 The problem the user has The solution your tool Setup instructions prerequisites how to install your tool verify that the tool has been properly installed. Step by step instructions to solve a simple trivial version \"the problem\" How to compile the solution How to test the solution Invitiation to solve the big problem Pointers to next documentation more steps. So let's look at an example \u00b6 Theory beyond this point. \u00b6 A developer \u00b6 You have written an extremely comples algorithm and you even went away and wrote a paper to explain it to the next person in charge of maintaining your code. But deep down you know that invariably over time your article and your code are going to diverge so much that neither will make any sense. A tester \u00b6 Writes an extremely complite integration test, it goes from zero just a brand new operating system. All the way to installation and it even runs a few subtests in the new environment in order to make sure that one the user installs the software for the first time, it can be succesful. Even more that integration test could be used as the basis for many tutorials if only, tech writers read the code. How can we solve those problems? \u00b6 Literate programming \u00b6 Is a programming paradigm introduced by Donald Knuth in which a computer program is given an explanation of its logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which compilable source code can be generated.[1] Philosophy \u00b6 \u201cPrograms must be written for people to read, and only incidentally for machines to execute.\u201d \u2015 Harold Abelson \u201cLet us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.\u201d \u2014 Donald Knuth Stages: \u00b6 Writting \u00b6 Writing about a comprehensive document about the program, the code and its maintenance. Weaving \u00b6 Generating a beautiful documentation Tangling \u00b6 Generating machine executable code \u00b6","title":"Documentation Rot"},{"location":"doc_rot/#software-rot","text":"Is a slow deterioration of software quality over time or its diminishing responsiveness that will eventually lead to software becoming faulty, unusable, or in need of upgrade. This is not a physical phenomenon: the software does not actually decay, but rather suffers from a lack of being responsive and updated with respect to the changing environment in which it resides.","title":"Software rot"},{"location":"doc_rot/#documentation-rot-is","text":"when your documentation stops working because the environment (programs, operating systems, libraries) has changed.","title":"Documentation rot is"},{"location":"doc_rot/#for-example","text":"","title":"For example"},{"location":"doc_rot/#as-tech-writer","text":"You write a tutorial and in the beginning everybody is happy with it. The explanations and the step by step instructions work well. However in just a few months and in the case of new techology even in a few days the tutorial doesn't work anymore frustrating new users and the writer. How can we avoid this destiny?","title":"As Tech writer"},{"location":"doc_rot/#literate-programming","text":"Is a programming paradigm in which the main goal is to write document, that explains to other humans the intentions of your code. By writing a book / article intertwined with code. Then the code is separated in an operation named Tangle And the article is prepared for publication in an operation called weaving","title":"Literate programming"},{"location":"doc_rot/#elments-of-a-software-tutorial","text":"Description of the software Installation and setup Prerequisites Installation Configuration (if needed) Basic example Example input step by step instructions that the user should perform Expected output Conclusion and next steps Given that I present a (basic tutorial to use pandoc)[../pandoc/]","title":"Elments of a software tutorial"},{"location":"doc_rot/#a-basic-tutorial-example","text":"","title":"A basic tutorial example"},{"location":"doc_rot/#clarity-is-not-enough","text":"Our tutorial is very, simple and easy to follow. But that is not enough, we also need correctness The instructions that we indicate the user should actually and reliably work. So to do that we need to convert our tutorial into a script ...","title":"Clarity is not enough"},{"location":"doc_rot/#a-clear-correct-tutorial-is-not-enough","text":"Our tutorial is clearly explained and we know that the instructions we provide the user are correct. Now we need to make sure, that the tutorial remains correct. So we need to monitor the environment on which our tutorial is still working","title":"A Clear, Correct tutorial is not enough..."},{"location":"doc_rot/#how-to-solve-it","text":"","title":"How to solve it."},{"location":"doc_rot/#lets-look-at-a-very-simple-tutorial-even-a-readme","text":"A typical tutorial includes the following sections:","title":"Let's look at a very simple tutorial, even a README"},{"location":"doc_rot/#example-for-a-tutorial","text":"The problem the user has The solution your tool Setup instructions prerequisites how to install your tool verify that the tool has been properly installed. Step by step instructions to solve a simple trivial version \"the problem\" How to compile the solution How to test the solution Invitiation to solve the big problem Pointers to next documentation more steps.","title":"Example for a tutorial"},{"location":"doc_rot/#so-lets-look-at-an-example","text":"","title":"So let's look at an example"},{"location":"doc_rot/#theory-beyond-this-point","text":"","title":"Theory beyond this point."},{"location":"doc_rot/#a-developer","text":"You have written an extremely comples algorithm and you even went away and wrote a paper to explain it to the next person in charge of maintaining your code. But deep down you know that invariably over time your article and your code are going to diverge so much that neither will make any sense.","title":"A developer"},{"location":"doc_rot/#a-tester","text":"Writes an extremely complite integration test, it goes from zero just a brand new operating system. All the way to installation and it even runs a few subtests in the new environment in order to make sure that one the user installs the software for the first time, it can be succesful. Even more that integration test could be used as the basis for many tutorials if only, tech writers read the code.","title":"A tester"},{"location":"doc_rot/#how-can-we-solve-those-problems","text":"","title":"How can we solve those problems?"},{"location":"doc_rot/#literate-programming_1","text":"Is a programming paradigm introduced by Donald Knuth in which a computer program is given an explanation of its logic in a natural language, such as English, interspersed with snippets of macros and traditional source code, from which compilable source code can be generated.[1]","title":"Literate programming"},{"location":"doc_rot/#philosophy","text":"\u201cPrograms must be written for people to read, and only incidentally for machines to execute.\u201d \u2015 Harold Abelson \u201cLet us change our traditional attitude to the construction of programs. Instead of imagining that our main task is to instruct a computer what to do, let us concentrate rather on explaining to human beings what we want a computer to do.\u201d \u2014 Donald Knuth","title":"Philosophy"},{"location":"doc_rot/#stages","text":"","title":"Stages:"},{"location":"doc_rot/#writting","text":"Writing about a comprehensive document about the program, the code and its maintenance.","title":"Writting"},{"location":"doc_rot/#weaving","text":"Generating a beautiful documentation","title":"Weaving"},{"location":"doc_rot/#tangling","text":"Generating machine executable code","title":"Tangling"},{"location":"doc_rot/#_1","text":"","title":""},{"location":"example_tutorial_pandoc/","text":"A basic pandoc tutorial \u00b7 \u00b6 The swiss-army knife to convert files. You can convert between this formats: \u2194\ufe0e Markdown (including CommonMark and GitHub-flavored Markdown) \u2194\ufe0e reStructuredText \u2192 AsciiDoc \u2194\ufe0e Emacs Org-Mode \u2194\ufe0e Emacs Muse \u2194\ufe0e Textile \u2190 txt2tags Installing / Getting started \u00b6 Installing Pandoc on Debian Ubuntu is very easy. #install_pandoc sudo apt install -y pandoc Converting from markdown to html \u00b6 As a basic example let's convert this markdown file to html5 file://tutorials/pandoc/hello_world.md # Hello World Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. > Aenean iaculis consectetur nisl vel egestas. In pandoc you would write #convert_from_md_to_html5 pandoc --from = markdown --to = html5 -s ./tutorials/pandoc/hello_world.md -o ./tutorials/pandoc/hello_world.html And then you would have hello_world.html file with the markdown converte to the correct one. file://tutorials/pandoc/tests/hello_world.html < h1 id = \"hello-world\" > Hello World </ h1 > < p > Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. </ p > < blockquote > < p > Aenean iaculis consectetur nisl vel egestas. </ p > </ blockquote > And with that we conclude the tutorial Automating the tutorial. \u00b6 Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: file://tutorials/pandoc/tests/scripted.test.sh #!/bin/bash set -euo pipefail IFS = $'\\n\\t' sudo su <<install_pandoc>> <<convert_from_md_to_html5>> <<veri fy_output_equal_expected_value>> How can we very the ouput equals the expected value? \u00b6 #verify_output_equal_expected_value if ! cmp ./tutorials/pandoc/hello_world.html ./tutorials/pandoc/tests/hello_world.html 2 > & 1 then echo \"The generated hello_world.html is not identical to the expected....\" exit 1 ; fi Monitoring \u00b6 To avoid documentation rot we need to make sure our tutorial works and continues to work day in and day out. Finally we need to keep writing this tests at least once a day, to make sure it continues to work. In order to do that we will use a GitHub Action. GitHub Actions are processes that get executed on GitHub's Servers when ever there is a push to your source code repository. file://.github/workflows/monitor_tutorial_tests.yml name : Schedule test execution on : schedule : - cron : \"0 0 * * *\" jobs : pull_data : runs-on : ubuntu-20.04 steps : - name : Checkout code uses : actions/checkout@v2 with : persist-credentials : false fetch-depth : 0 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" # Let's execute the testing script - name : Execute test scripts for all the tutorials run : find ./tutorials/ -name \"*.test.sh\" | xargs bash","title":"An example tutorial"},{"location":"example_tutorial_pandoc/#a-basic-pandoc-tutorial","text":"The swiss-army knife to convert files. You can convert between this formats: \u2194\ufe0e Markdown (including CommonMark and GitHub-flavored Markdown) \u2194\ufe0e reStructuredText \u2192 AsciiDoc \u2194\ufe0e Emacs Org-Mode \u2194\ufe0e Emacs Muse \u2194\ufe0e Textile \u2190 txt2tags","title":"A basic pandoc tutorial &middot;"},{"location":"example_tutorial_pandoc/#installing-getting-started","text":"Installing Pandoc on Debian Ubuntu is very easy. #install_pandoc sudo apt install -y pandoc","title":"Installing / Getting started"},{"location":"example_tutorial_pandoc/#converting-from-markdown-to-html","text":"As a basic example let's convert this markdown file to html5 file://tutorials/pandoc/hello_world.md # Hello World Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. > Aenean iaculis consectetur nisl vel egestas. In pandoc you would write #convert_from_md_to_html5 pandoc --from = markdown --to = html5 -s ./tutorials/pandoc/hello_world.md -o ./tutorials/pandoc/hello_world.html And then you would have hello_world.html file with the markdown converte to the correct one. file://tutorials/pandoc/tests/hello_world.html < h1 id = \"hello-world\" > Hello World </ h1 > < p > Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean augue neque, mattis nec mollis id, dictum at purus. Nullam ac justo tempor, hendrerit nisl sit amet, rutrum ex. </ p > < blockquote > < p > Aenean iaculis consectetur nisl vel egestas. </ p > </ blockquote > And with that we conclude the tutorial","title":"Converting from markdown to html"},{"location":"example_tutorial_pandoc/#automating-the-tutorial","text":"Now what we want is to create script / program that we can automatically execute with the steps we told the user to follow. A script that looks like this: file://tutorials/pandoc/tests/scripted.test.sh #!/bin/bash set -euo pipefail IFS = $'\\n\\t' sudo su <<install_pandoc>> <<convert_from_md_to_html5>> <<veri fy_output_equal_expected_value>>","title":"Automating the tutorial."},{"location":"example_tutorial_pandoc/#how-can-we-very-the-ouput-equals-the-expected-value","text":"#verify_output_equal_expected_value if ! cmp ./tutorials/pandoc/hello_world.html ./tutorials/pandoc/tests/hello_world.html 2 > & 1 then echo \"The generated hello_world.html is not identical to the expected....\" exit 1 ; fi","title":"How can we very the ouput equals the expected value?"},{"location":"example_tutorial_pandoc/#monitoring","text":"To avoid documentation rot we need to make sure our tutorial works and continues to work day in and day out. Finally we need to keep writing this tests at least once a day, to make sure it continues to work. In order to do that we will use a GitHub Action. GitHub Actions are processes that get executed on GitHub's Servers when ever there is a push to your source code repository. file://.github/workflows/monitor_tutorial_tests.yml name : Schedule test execution on : schedule : - cron : \"0 0 * * *\" jobs : pull_data : runs-on : ubuntu-20.04 steps : - name : Checkout code uses : actions/checkout@v2 with : persist-credentials : false fetch-depth : 0 - name : Set up Python 3.8 uses : actions/setup-python@v2 with : python-version : \"3.8\" # Let's execute the testing script - name : Execute test scripts for all the tutorials run : find ./tutorials/ -name \"*.test.sh\" | xargs bash","title":"Monitoring"},{"location":"setup/","text":"Entangled and MkDocs \u00b6 This is a setup of Entangled with MkDocs, using: mkdocs-material theme (which is almost a cms) mathjax Prep \u00b6 Install entangled (\u2265 1.2) following the instructions at entangled.github.io . #install_entangled RUN wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ Install the entangled-filters Python module (\u2265 0.7) #install_filters RUN sudo pip install entangled-filters Install mkdocs #install_mkdocs RUN sudo pip install mkdocs Install material theme #install_mkdocs_material RUN sudo pip install mkdocs-material This could be setup in a docker file with this structure \u00b6 file://.gitpod.Dockerfile FROM gitpod/workspace-full <<install_entangled>> <<install_fi lters>> <<install_mkdocs>> <<install_mkdocs_materi al>> Starting a project \u00b6 To run Entangled we need a entangled.dhall configuration file. The following command generates a file that you can edit to suit your needs. entangled config > entangled.dhall We have our Markdown inside the docs folder, so you'll need to set the watchList variable to [ \"docs/**/*.md\" ] . let watchList = [ \"docs/**/*.md\" ] In this project we use a different Markdown syntax than is standard with Entangled. ```cpp title=\"file://src/hello.cc\" ``` ```cpp title=\"#print-hello\" ``` To match these code blocks, we need to change the syntax value in the configuration. let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file=\\\"([^\\\"]*)\\\".*\" } To initiate a MkDocs project, you need a mkdocs.yml file. This contains the meta-data of the site, file://mkdocs.yml nav : - Home : \"index.md\" - Documentation Rot : \"doc_rot.md\" - An example tutorial : \"example_tutorial_pandoc.md\" - About : \"about.md\" - Experiments : \"syntax_experiments.md\" - Deployment : \"deployment.md\" site_name : TODO insert your site name site_url : https://TODO.github.io/_project_name repo_url : https://github.com/TODO/mkdocs site_description : > TODO describe your site site_author : TODO your name copyright : TODO your organization's name and the configuration file://mkdocs.yml <<theme>> markdown_extensions : <<markdown-extensions>> - admonition - toc : permalink : true extra_css : <<extra-css>> extra_javascript : <<extra-javascript>> Material theme \u00b6 Install the material theme with pip install mkdocs-material #theme theme : name : material Annotating code blocks \u00b6 The entangled-filters module, while mainly dedicated to Pandoc support, has a few functions to help us pass metadata through mkdocs . By default, mkdocs will not allow any extra attributes to be added to the code blocks. We need to configure pymdownx.superfences extension to get what we need. #markdown-extensions - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences Highlighting \u00b6 To enable syntax highlighting you need to configure highlight.js . #extra-css Equations \u00b6 Here's everything we know about gravity \\[G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \\frac{8\\pi G}{c^4} T_{\\mu\\nu}\\] #markdown-extensions - pymdownx.arithmatex #extra-javascript - \"https://polyfill.io/v3/polyfill.min.js?features=es6\" - \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"","title":"Setup"},{"location":"setup/#entangled-and-mkdocs","text":"This is a setup of Entangled with MkDocs, using: mkdocs-material theme (which is almost a cms) mathjax","title":"Entangled and MkDocs"},{"location":"setup/#prep","text":"Install entangled (\u2265 1.2) following the instructions at entangled.github.io . #install_entangled RUN wget https://github.com/entangled/entangled/releases/download/v1.2.4/entangled-1.2.4-x86_64-GNU-Linux.tar.xz && tar --extract --file entangled-1.2.4-x86_64-GNU-Linux.tar.xz && sudo cp -r ./entangled-1.2.4/* /usr/local/ Install the entangled-filters Python module (\u2265 0.7) #install_filters RUN sudo pip install entangled-filters Install mkdocs #install_mkdocs RUN sudo pip install mkdocs Install material theme #install_mkdocs_material RUN sudo pip install mkdocs-material","title":"Prep"},{"location":"setup/#this-could-be-setup-in-a-docker-file-with-this-structure","text":"file://.gitpod.Dockerfile FROM gitpod/workspace-full <<install_entangled>> <<install_fi lters>> <<install_mkdocs>> <<install_mkdocs_materi al>>","title":"This could be setup in a docker file with this structure"},{"location":"setup/#starting-a-project","text":"To run Entangled we need a entangled.dhall configuration file. The following command generates a file that you can edit to suit your needs. entangled config > entangled.dhall We have our Markdown inside the docs folder, so you'll need to set the watchList variable to [ \"docs/**/*.md\" ] . let watchList = [ \"docs/**/*.md\" ] In this project we use a different Markdown syntax than is standard with Entangled. ```cpp title=\"file://src/hello.cc\" ``` ```cpp title=\"#print-hello\" ``` To match these code blocks, we need to change the syntax value in the configuration. let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file=\\\"([^\\\"]*)\\\".*\" } To initiate a MkDocs project, you need a mkdocs.yml file. This contains the meta-data of the site, file://mkdocs.yml nav : - Home : \"index.md\" - Documentation Rot : \"doc_rot.md\" - An example tutorial : \"example_tutorial_pandoc.md\" - About : \"about.md\" - Experiments : \"syntax_experiments.md\" - Deployment : \"deployment.md\" site_name : TODO insert your site name site_url : https://TODO.github.io/_project_name repo_url : https://github.com/TODO/mkdocs site_description : > TODO describe your site site_author : TODO your name copyright : TODO your organization's name and the configuration file://mkdocs.yml <<theme>> markdown_extensions : <<markdown-extensions>> - admonition - toc : permalink : true extra_css : <<extra-css>> extra_javascript : <<extra-javascript>>","title":"Starting a project"},{"location":"setup/#material-theme","text":"Install the material theme with pip install mkdocs-material #theme theme : name : material","title":"Material theme"},{"location":"setup/#annotating-code-blocks","text":"The entangled-filters module, while mainly dedicated to Pandoc support, has a few functions to help us pass metadata through mkdocs . By default, mkdocs will not allow any extra attributes to be added to the code blocks. We need to configure pymdownx.superfences extension to get what we need. #markdown-extensions - pymdownx.highlight : anchor_linenums : true - pymdownx.inlinehilite - pymdownx.snippets - pymdownx.superfences","title":"Annotating code blocks"},{"location":"setup/#highlighting","text":"To enable syntax highlighting you need to configure highlight.js . #extra-css","title":"Highlighting"},{"location":"setup/#equations","text":"Here's everything we know about gravity \\[G_{\\mu\\nu} + \\Lambda g_{\\mu\\nu} = \\frac{8\\pi G}{c^4} T_{\\mu\\nu}\\] #markdown-extensions - pymdownx.arithmatex #extra-javascript - \"https://polyfill.io/v3/polyfill.min.js?features=es6\" - \"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"","title":"Equations"},{"location":"slasher/","text":"What better waste of time than writing a mind numbing game in a language you don't know? Let's dive into Elm . Elm is a strongly typed functional language that compiles to JavaScript. Its design is centred around the Model/View/Controller concept. This document may teach you: Basics of Elm Writing a small browser based game Random numbers in Elm (through Cmd/Msg loop) Generate SVG Our game is simple. The original slasher game is one I remember from way back when I was playing with GW Basic . Your hero is zipping around the screen at break neck speeds and the only way to control him is by placing slash \u2571 and backslash \u2572 characters from which it bounces off. The goal is to catch the golden snitch which only stays in one place for so long. {#fig:slasher-screenshot} You can play this game here. Main \u00b6 Elm has a set of different application formats, depending on the level of interactivity that is needed: sandbox : has no interaction with outside world, except through buttons, text fields and forms. element : can talk to HTTP, use random numbers, and capture browser events. document : similar to element, but generates the entire document. application : also handles URL requests and URL changes. The Elm guide has a section describing the difference between sandbox and element . The event loop of element looks like this: {#fig:elm-event-loop} We will be creating an element program, compile it to a JavaScript file, and create a HTML and CSS around it by hand. The lay-out of such a program in Elm looks as follows: module Main exposing (..) << imports >> << main >> << model >> << update >> << subscriptions >> << view >> The main function tells Elm that we create an element main main = Browser . element { init = init , update = update , subscriptions = subscriptions , view = view } The rest of the program has: model : Data model of the game. In strongly typed functional languages the design of a program always starts with thinking about type definitions. update : Defines how to propagate the model from one state to the next. subscriptions : Subscriptions to external events, that is, events that cannot be bound to an action on a HTML element. view : Describes how to translate the model state into an HTML element. Imports \u00b6 imports import Browser import Array exposing ( Array , repeat , indexedMap , toList , set , get ) import List exposing ( concat ) import Browser.Events exposing ( onAnimationFrameDelta , onKeyDown ) import Html exposing ( Html , button , div , text , p , input , main_ , a ) import Html.Attributes exposing ( href ) import Html.Events exposing ( onClick , preventDefaultOn ) import Svg exposing ( svg , circle , line , rect , g , polygon , text_ ) import Svg.Attributes exposing (..) import Random import Json.Decode as Decode The Model \u00b6 The model will be a grid of cells and two actors: our hero and the snitch (if you like to play around with the code, try to add a list of enemy actors that can hurt the hero). type alias Model = { actors : { player : Actor , snitch : Actor } , grid : Grid , snitchTime : Float , state : GameState } In addition to the actors and the grid , we have to keep time, and a game state flag. The game state tells us if the game is running etc. type GameState = Start | Running | Pause | Won We define the grid as nested arrays of cells, where each cell can have the value Empty , Slash or BackSlash : type alias Grid = Array ( Array Cell ) type Cell = Empty | Slash | BackSlash gridRef : ( Int , Int ) -> Grid -> Cell gridRef ( i , j ) grid = Maybe . withDefault Empty <| Maybe . andThen ( \\ row -> get i row ) ( get j grid ) gridSet : ( Int , Int ) -> Cell -> Grid -> Grid gridSet ( i , j ) cell grid = let row_ = get j grid in case row_ of Nothing -> grid Just row -> set j ( set i cell row ) grid Lastly, an Actor is something that has a location and a velocity, each a 2-tuple of floats. type alias Actor = { location : ( Float , Float ) , velocity : ( Float , Float ) } Config \u00b6 type alias Config = { gridSize : ( Int , Int ) , playerSpeed : Float , scale : Int , snitchTime : Float } config : Config config = { gridSize = ( 80 , 50 ) , playerSpeed = 0. 03 , scale = 15 , snitchTime = 10000 } inRange : ( Int , Int ) -> Bool inRange ( i , j ) = let ( w , h ) = config . gridSize in i >= 0 && i < w && j >= 0 && j < h Init \u00b6 The model is initialised by the init function. This function has the funny signature () -> (Model, Cmd Msg) . We'll return to the type definition of Msg later, but what this means is that the init function generates an initial state and a command (or list of commands) that tells the Elm run-time to perform an action upon initialisation. Such an action can be anything that requires some form of external state: HTTP requests, location/time information, and in our case: generating random numbers. init : () -> ( Model , Cmd Msg ) init _ = let ( width , height ) = config . gridSize playerLoc = (( toFloat width ) / 2 + 0. 5 , 2. 5 ) in ( { actors = { player = { location = playerLoc , velocity = ( 0. 0 , config . playerSpeed ) } , snitch = { location = ( 0. 0 , 0. 0 ) , velocity = ( 0. 0 , 0. 0 ) } } , grid = makeGrid config . gridSize , snitchTime = 0. 0 , state = Start }, Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( width - 1 )) ( Random . int 0 ( height - 1 )))) makeGrid : ( Int , Int ) -> Array ( Array Cell ) makeGrid ( width , height ) = Array . repeat height ( Array . repeat width Empty ) Subscriptions \u00b6 keyDecoder : Decode . Decoder Msg keyDecoder = Decode . map KeyPress ( Decode . field \"key\" Decode . string ) subscriptions : Model -> Sub Msg subscriptions model = Sub . batch [ onAnimationFrameDelta TimeStep , onKeyDown keyDecoder ] Update \u00b6 The update function has the following signature: update : Msg -> Model -> ( Model , Cmd Msg ) This means that, given a message and a model state, we can generate a new model state and a list of requests to the Elm run-time. This list of requests has the type Cmd Msg , telling Elm that, whatever the request, it has to respond with a Msg . type Msg = KeyPress String | TimeStep Float | PlaceSnitch ( Int , Int ) In our case, a message is either a KeyPress indicating a key being pressed, a TimeStep when a new animation frame is triggered or a PlaceSnitch when the random number generator returns a fresh pair of coordinates. We'll defer the handling of these messages to helper functions. update msg model = case msg of TimeStep dt -> let next = timeStep dt model in ( next , checkSnitchTime next ) KeyPress k -> ( keyMap k model , Cmd . none ) PlaceSnitch l -> ( placeSnitch l model , Cmd . none ) << msg - type >> << update - function >> Time step \u00b6 Each time step, if the game in in Running state, we need to check if the game is won, and otherwise move all actors that need moving. timeStep : Float -> Model -> Model timeStep dt ({ actors , grid , snitchTime , state } as model ) = case state of Running -> if didWeWin model then { model | state = Won } else { model | snitchTime = snitchTime - dt , actors = { actors | player = updateActor grid dt actors . player } } _ -> model Did we win? \u00b6 didWeWin : Model -> Bool didWeWin ({ actors } as model ) = activeCell actors . snitch == activeCell actors . player Update actors \u00b6 Updating an actor is a bit of boring bookkeeping. We check whether the actor's active grid cell changes. This happens when the actor moves across the center of a cell. If the active cell changed, potentially the actor bounced off a (back)slash or a wall. updateActor : Grid -> Float -> Actor -> Actor updateActor grid dt actor = let a = activeCell actor b = activeCell <| moveActor dt actor in if a /= b then case ( gridRef a grid ) of Slash -> bounceActor dt Slash actor BackSlash -> bounceActor dt BackSlash actor Empty -> if inRange b then moveActor dt actor else bounceOffWall dt actor else moveActor dt actor Active cell \u00b6 To get a smooth flying experience the actors have floating point coordinates. From the coordinates we need to compute the integer indices into the grid. activeCell : Actor -> ( Int , Int ) activeCell actor = let ( x , y ) = actor . location in case ( actorDirection actor ) of East -> ( round x , floor y ) West -> ( round ( x - 1. 0 ), floor y ) North -> ( floor x , round ( y - 1. 0 )) South -> ( floor x , round y ) Direction \u00b6 From the velocity we often need to know in which of the four cardinal directions an actor is moving. type Direction = North | East | South | West actorDirection : Actor -> Direction actorDirection actor = let ( vx , vy ) = actor . velocity in if ( abs vx ) > ( abs vy ) then if vx > 0 then East else West else if vy > 0 then South else North Actor dynamics \u00b6 When an actor moves, it may do so in one of three ways: move without obstacle bounce off a (back)slash) bounce off the wall For each of these cases we have a separate function. moveActor : Float -> Actor -> Actor moveActor dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity in { actor | location = ( x + dt * vx , y + dt * vy ) } bounceActor : Float -> Cell -> Actor -> Actor bounceActor dt cell actor = let ( i , j ) = activeCell actor ( vx , vy ) = actor . velocity newloc = (( toFloat i ) + 0. 5 , ( toFloat j ) + 0. 5 ) in case cell of Slash -> moveActor dt { location = newloc , velocity = ( - vy , - vx ) } BackSlash -> moveActor dt { location = newloc , velocity = ( vy , vx ) } Empty -> actor bounceOffWall : Float -> Actor -> Actor bounceOffWall dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity newloc = case actorDirection actor of North -> ( x , 0. 0 ) South -> ( x , 50. 0 ) East -> ( 80. 0 , y ) West -> ( 0. 0 , y ) in moveActor dt { location = newloc , velocity = ( - vx , - vy ) } Snitch time \u00b6 Each time step we decreased the snitchTime field. If it drops below 0, we ask the Elm runtime for a new random snitch location. checkSnitchTime : Model -> Cmd Msg checkSnitchTime { snitchTime } = let ( w , h ) = config . gridSize in if snitchTime < 0. 0 then Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( w - 1 )) ( Random . int 0 ( h - 1 ))) else Cmd . none Moving the snitch \u00b6 When the snitch is placed we reset the snitchTime to the configured value placeSnitch : ( Int , Int ) -> Model -> Model placeSnitch ( x , y ) ({ actors } as model ) = { model | snitchTime = config . snitchTime , actors = { actors | snitch = { location = (( toFloat x ) + 0. 5 , ( toFloat y ) + 0. 5 ) , velocity = ( 0. 0 , 0. 0 ) } } } Keymap \u00b6 We listen to three keys: space, left arrow and right arrow. We could have listened for \\ and / keys, but in Firefox the / key also activates quick search. We could work around this, but it is a bit of a hassle. keyMap : String -> Model -> Model keyMap k ({ state } as model ) = let slash cell = if state == Running then place cell model else model in case k of \" \" -> let newState = case state of Running -> Pause Start -> Running Pause -> Running Won -> Won in { model | state = newState } \"ArrowLeft\" -> slash BackSlash \"ArrowRight\" -> slash Slash _ -> model Placing a (back)slash \u00b6 place : Cell -> Model -> Model place cell ({ actors , grid } as model ) = let loc = activeCell actors . player in { model | grid = gridSet loc cell grid } View \u00b6 scale : Int scale = config . scale fScale : Float fScale = toFloat scale viewCell : ( Int , Int ) -> Cell -> List ( Html Msg ) viewCell ( i , j ) c = case c of Slash -> [ line [ x1 ( String . fromInt ( scale * i + scale )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] BackSlash -> [ line [ x1 ( String . fromInt ( scale * i )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i + scale )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] Empty -> [] formatPath : List ( Float , Float ) -> String formatPath pts = case pts of [] -> \"\" ( x , y ) :: rest -> ( String . fromFloat <| x * fScale ) ++ \",\" ++ ( String . fromFloat <| y * fScale ) ++ \" \" ++ formatPath rest viewHero : Actor -> Html Msg viewHero actor = let ( x , y ) = actor . location path = case actorDirection actor of South -> [ ( x , y ) , ( x + 0. 3 , y - 1 ) , ( x - 0. 3 , y - 1 ) ] North -> [ ( x , y ) , ( x + 0. 3 , y + 1 ) , ( x - 0. 3 , y + 1 ) ] West -> [ ( x , y ) , ( x + 1 , y + 0. 3 ) , ( x + 1 , y - 0. 3 ) ] East -> [ ( x , y ) , ( x - 1 , y + 0. 3 ) , ( x - 1 , y - 0. 3 ) ] in polygon [ points <| formatPath path , class \"hero\" ] [] viewSnitch : Actor -> Html Msg viewSnitch actor = let ( x , y ) = actor . location in circle [ cx ( String . fromFloat <| x * fScale ) , cy ( String . fromFloat <| y * fScale ) , r ( String . fromInt <| scale // 2 ) , class \"snitch\" ] [] viewOverlay : GameState -> Html Msg viewOverlay state = let ( w , h ) = config . gridSize sWidth = ( String . fromInt <| config . scale * w ) sHeight = ( String . fromInt <| config . scale * h ) middleX = ( String . fromInt <| config . scale * w // 2 ) middleY = ( String . fromInt <| config . scale * h // 2 ) rectA = rect [ x \"0\" , y \"0\" , width sWidth , height sHeight , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , style \"fill: black\" ] [] textA s = text_ [ x middleX , y middleY , textAnchor \"middle\" ] [ text s ] overlay s = g [ id \"overlay\" ] [ rectA , textA s ] in case state of Running -> g [] [] Won -> overlay \"YOU WIN!\" Start -> overlay \"press space to start\" Pause -> overlay \"PAUSE\" viewSnitchBar : Float -> Html Msg viewSnitchBar t = let u = t / config . snitchTime ( w , h ) = config . gridSize sWidth = String . fromFloat <| ( toFloat w ) * u * ( toFloat config . scale ) in rect [ x \"0\" , y ( String . fromInt <| h * config . scale + 10 ) , width sWidth , height ( String . fromInt <| config . scale // 2 ) , id \"snitch-bar\" ] [] viewArena : Model -> Html Msg viewArena ({ actors , grid , state , snitchTime } as model ) = let blurAtPause = class <| if state == Running then \"non-blurred\" else \"blurred\" in svg [ width \"100%\" , viewBox ( \"-3 -3 \" ++ ( String . fromInt <| scale * 80 + 4 ) ++ \" \" ++ ( String . fromInt <| scale * 50 + 24 ))] [ g [] [ rect [ x \"0\" , y \"0\" , width ( String . fromInt ( scale * 80 )) , height ( String . fromInt ( scale * 50 )) , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , id \"box\" ] []] , g [ blurAtPause ] ( concat ( toList ( indexedMap ( \\ y rows -> ( concat ( toList ( indexedMap ( \\ x cell -> viewCell ( x , y ) cell ) rows )))) grid ))) , g [ blurAtPause ] [ viewHero actors . player , viewSnitch actors . snitch ] , ( viewOverlay state ) , ( viewSnitchBar snitchTime ) ] view : Model -> Html Msg view model = main_ [] [ div [ id \"header\" ] [ text \" \\\\ \\\\ S L A S H E R / /\" ] , div [ id \"arena\" ] [ viewArena model ] , div [ id \"help\" ] [ text \"keys: Left \\\\ | Right / | Space pause\" ] , div [ id \"footer\" ] [ text \"Use the source, at \" , a [ href \"https://entangled.github.io/\" ] [ text \"Entangled!\" ] ] ] Completing the game \u00b6 From the code we can either build a HTML or a JavaScript file for embedding. We will manually create the HTML so that we can also create a stylesheet. Here's the Makefile for creating an optimized and uglified version of slasher (you can install uglifyjs with npm install -g uglify-js ): .PHONY : build build : slasher . min . js slasher.js : src / Main . elm elm make src/Main.elm --output = slasher.js --optimize slasher.min.js : slasher . js uglifyjs slasher.js --compress 'pure_funcs=\"F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9\",pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output = slasher.min.js The HTML can be very short now: <!DOCTYPE html> < html > < head > < title > Slasher </ title > < meta charset = \"UTF-8\" > < < google-font > > < link rel = \"stylesheet\" href = \"css/slasher.css\" > </ head > < body > < div id = \"slasher\" ></ div > < script src = \"js/slasher.min.js\" ></ script > < script > Elm . Main . init ({ node : document . getElementById ( \"slasher\" ) }); </ script > </ body > </ html > Browse Google fonts for a nice slashery font: < link href = \"https://fonts.googleapis.com/css?family=Love+Ya+Like+A+Sister\" rel = \"stylesheet\" > And add some style body { font-family : \"Love Ya Like A Sister\" , sans serif ; background-image : radial-gradient ( circle , #112233 , #000033 ); color : white ; } # arena svg { max-height : 80 vh ; } # header { font-size : 20 pt ; text-align : center ; margin-bottom : 5 pt ; } # help { text-align : center ; } # footer { font-family : sans serif ; font-size : 8 pt ; background : #ffffff 44 ; color : black ; text-align : center ; padding : 4 pt 0 ; margin : 10 pt 0 0 0 ; border-radius : 5 pt ; } # footer a { color : #202 ; } . blurred { filter : blur ( 1 pt ); } /* svg #overlay { filter: blur(1pt); } */ svg # overlay rect { opacity : 0.3 ; fill : black ; } svg # overlay text { font-size : 70 pt ; fill : white ; } svg # box { opacity : 0.5 ; stroke : goldenrod ; stroke-width : 2 pt ; fill : none ; } svg line . slash { stroke : #8888ff ; stroke-width : 2 pt ; } svg . hero { fill : red ; stroke : black ; } svg . snitch { fill : gold ; stroke : black ; } svg # snitch-bar { opacity : 0.8 ; fill : gold ; stroke : black ; }","title":"Slasher"},{"location":"slasher/#main","text":"Elm has a set of different application formats, depending on the level of interactivity that is needed: sandbox : has no interaction with outside world, except through buttons, text fields and forms. element : can talk to HTTP, use random numbers, and capture browser events. document : similar to element, but generates the entire document. application : also handles URL requests and URL changes. The Elm guide has a section describing the difference between sandbox and element . The event loop of element looks like this: {#fig:elm-event-loop} We will be creating an element program, compile it to a JavaScript file, and create a HTML and CSS around it by hand. The lay-out of such a program in Elm looks as follows: module Main exposing (..) << imports >> << main >> << model >> << update >> << subscriptions >> << view >> The main function tells Elm that we create an element main main = Browser . element { init = init , update = update , subscriptions = subscriptions , view = view } The rest of the program has: model : Data model of the game. In strongly typed functional languages the design of a program always starts with thinking about type definitions. update : Defines how to propagate the model from one state to the next. subscriptions : Subscriptions to external events, that is, events that cannot be bound to an action on a HTML element. view : Describes how to translate the model state into an HTML element.","title":"Main"},{"location":"slasher/#imports","text":"imports import Browser import Array exposing ( Array , repeat , indexedMap , toList , set , get ) import List exposing ( concat ) import Browser.Events exposing ( onAnimationFrameDelta , onKeyDown ) import Html exposing ( Html , button , div , text , p , input , main_ , a ) import Html.Attributes exposing ( href ) import Html.Events exposing ( onClick , preventDefaultOn ) import Svg exposing ( svg , circle , line , rect , g , polygon , text_ ) import Svg.Attributes exposing (..) import Random import Json.Decode as Decode","title":"Imports"},{"location":"slasher/#the-model","text":"The model will be a grid of cells and two actors: our hero and the snitch (if you like to play around with the code, try to add a list of enemy actors that can hurt the hero). type alias Model = { actors : { player : Actor , snitch : Actor } , grid : Grid , snitchTime : Float , state : GameState } In addition to the actors and the grid , we have to keep time, and a game state flag. The game state tells us if the game is running etc. type GameState = Start | Running | Pause | Won We define the grid as nested arrays of cells, where each cell can have the value Empty , Slash or BackSlash : type alias Grid = Array ( Array Cell ) type Cell = Empty | Slash | BackSlash gridRef : ( Int , Int ) -> Grid -> Cell gridRef ( i , j ) grid = Maybe . withDefault Empty <| Maybe . andThen ( \\ row -> get i row ) ( get j grid ) gridSet : ( Int , Int ) -> Cell -> Grid -> Grid gridSet ( i , j ) cell grid = let row_ = get j grid in case row_ of Nothing -> grid Just row -> set j ( set i cell row ) grid Lastly, an Actor is something that has a location and a velocity, each a 2-tuple of floats. type alias Actor = { location : ( Float , Float ) , velocity : ( Float , Float ) }","title":"The Model"},{"location":"slasher/#config","text":"type alias Config = { gridSize : ( Int , Int ) , playerSpeed : Float , scale : Int , snitchTime : Float } config : Config config = { gridSize = ( 80 , 50 ) , playerSpeed = 0. 03 , scale = 15 , snitchTime = 10000 } inRange : ( Int , Int ) -> Bool inRange ( i , j ) = let ( w , h ) = config . gridSize in i >= 0 && i < w && j >= 0 && j < h","title":"Config"},{"location":"slasher/#init","text":"The model is initialised by the init function. This function has the funny signature () -> (Model, Cmd Msg) . We'll return to the type definition of Msg later, but what this means is that the init function generates an initial state and a command (or list of commands) that tells the Elm run-time to perform an action upon initialisation. Such an action can be anything that requires some form of external state: HTTP requests, location/time information, and in our case: generating random numbers. init : () -> ( Model , Cmd Msg ) init _ = let ( width , height ) = config . gridSize playerLoc = (( toFloat width ) / 2 + 0. 5 , 2. 5 ) in ( { actors = { player = { location = playerLoc , velocity = ( 0. 0 , config . playerSpeed ) } , snitch = { location = ( 0. 0 , 0. 0 ) , velocity = ( 0. 0 , 0. 0 ) } } , grid = makeGrid config . gridSize , snitchTime = 0. 0 , state = Start }, Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( width - 1 )) ( Random . int 0 ( height - 1 )))) makeGrid : ( Int , Int ) -> Array ( Array Cell ) makeGrid ( width , height ) = Array . repeat height ( Array . repeat width Empty )","title":"Init"},{"location":"slasher/#subscriptions","text":"keyDecoder : Decode . Decoder Msg keyDecoder = Decode . map KeyPress ( Decode . field \"key\" Decode . string ) subscriptions : Model -> Sub Msg subscriptions model = Sub . batch [ onAnimationFrameDelta TimeStep , onKeyDown keyDecoder ]","title":"Subscriptions"},{"location":"slasher/#update","text":"The update function has the following signature: update : Msg -> Model -> ( Model , Cmd Msg ) This means that, given a message and a model state, we can generate a new model state and a list of requests to the Elm run-time. This list of requests has the type Cmd Msg , telling Elm that, whatever the request, it has to respond with a Msg . type Msg = KeyPress String | TimeStep Float | PlaceSnitch ( Int , Int ) In our case, a message is either a KeyPress indicating a key being pressed, a TimeStep when a new animation frame is triggered or a PlaceSnitch when the random number generator returns a fresh pair of coordinates. We'll defer the handling of these messages to helper functions. update msg model = case msg of TimeStep dt -> let next = timeStep dt model in ( next , checkSnitchTime next ) KeyPress k -> ( keyMap k model , Cmd . none ) PlaceSnitch l -> ( placeSnitch l model , Cmd . none ) << msg - type >> << update - function >>","title":"Update"},{"location":"slasher/#time-step","text":"Each time step, if the game in in Running state, we need to check if the game is won, and otherwise move all actors that need moving. timeStep : Float -> Model -> Model timeStep dt ({ actors , grid , snitchTime , state } as model ) = case state of Running -> if didWeWin model then { model | state = Won } else { model | snitchTime = snitchTime - dt , actors = { actors | player = updateActor grid dt actors . player } } _ -> model","title":"Time step"},{"location":"slasher/#did-we-win","text":"didWeWin : Model -> Bool didWeWin ({ actors } as model ) = activeCell actors . snitch == activeCell actors . player","title":"Did we win?"},{"location":"slasher/#update-actors","text":"Updating an actor is a bit of boring bookkeeping. We check whether the actor's active grid cell changes. This happens when the actor moves across the center of a cell. If the active cell changed, potentially the actor bounced off a (back)slash or a wall. updateActor : Grid -> Float -> Actor -> Actor updateActor grid dt actor = let a = activeCell actor b = activeCell <| moveActor dt actor in if a /= b then case ( gridRef a grid ) of Slash -> bounceActor dt Slash actor BackSlash -> bounceActor dt BackSlash actor Empty -> if inRange b then moveActor dt actor else bounceOffWall dt actor else moveActor dt actor","title":"Update actors"},{"location":"slasher/#active-cell","text":"To get a smooth flying experience the actors have floating point coordinates. From the coordinates we need to compute the integer indices into the grid. activeCell : Actor -> ( Int , Int ) activeCell actor = let ( x , y ) = actor . location in case ( actorDirection actor ) of East -> ( round x , floor y ) West -> ( round ( x - 1. 0 ), floor y ) North -> ( floor x , round ( y - 1. 0 )) South -> ( floor x , round y )","title":"Active cell"},{"location":"slasher/#direction","text":"From the velocity we often need to know in which of the four cardinal directions an actor is moving. type Direction = North | East | South | West actorDirection : Actor -> Direction actorDirection actor = let ( vx , vy ) = actor . velocity in if ( abs vx ) > ( abs vy ) then if vx > 0 then East else West else if vy > 0 then South else North","title":"Direction"},{"location":"slasher/#actor-dynamics","text":"When an actor moves, it may do so in one of three ways: move without obstacle bounce off a (back)slash) bounce off the wall For each of these cases we have a separate function. moveActor : Float -> Actor -> Actor moveActor dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity in { actor | location = ( x + dt * vx , y + dt * vy ) } bounceActor : Float -> Cell -> Actor -> Actor bounceActor dt cell actor = let ( i , j ) = activeCell actor ( vx , vy ) = actor . velocity newloc = (( toFloat i ) + 0. 5 , ( toFloat j ) + 0. 5 ) in case cell of Slash -> moveActor dt { location = newloc , velocity = ( - vy , - vx ) } BackSlash -> moveActor dt { location = newloc , velocity = ( vy , vx ) } Empty -> actor bounceOffWall : Float -> Actor -> Actor bounceOffWall dt actor = let ( x , y ) = actor . location ( vx , vy ) = actor . velocity newloc = case actorDirection actor of North -> ( x , 0. 0 ) South -> ( x , 50. 0 ) East -> ( 80. 0 , y ) West -> ( 0. 0 , y ) in moveActor dt { location = newloc , velocity = ( - vx , - vy ) }","title":"Actor dynamics"},{"location":"slasher/#snitch-time","text":"Each time step we decreased the snitchTime field. If it drops below 0, we ask the Elm runtime for a new random snitch location. checkSnitchTime : Model -> Cmd Msg checkSnitchTime { snitchTime } = let ( w , h ) = config . gridSize in if snitchTime < 0. 0 then Random . generate PlaceSnitch ( Random . pair ( Random . int 0 ( w - 1 )) ( Random . int 0 ( h - 1 ))) else Cmd . none","title":"Snitch time"},{"location":"slasher/#moving-the-snitch","text":"When the snitch is placed we reset the snitchTime to the configured value placeSnitch : ( Int , Int ) -> Model -> Model placeSnitch ( x , y ) ({ actors } as model ) = { model | snitchTime = config . snitchTime , actors = { actors | snitch = { location = (( toFloat x ) + 0. 5 , ( toFloat y ) + 0. 5 ) , velocity = ( 0. 0 , 0. 0 ) } } }","title":"Moving the snitch"},{"location":"slasher/#keymap","text":"We listen to three keys: space, left arrow and right arrow. We could have listened for \\ and / keys, but in Firefox the / key also activates quick search. We could work around this, but it is a bit of a hassle. keyMap : String -> Model -> Model keyMap k ({ state } as model ) = let slash cell = if state == Running then place cell model else model in case k of \" \" -> let newState = case state of Running -> Pause Start -> Running Pause -> Running Won -> Won in { model | state = newState } \"ArrowLeft\" -> slash BackSlash \"ArrowRight\" -> slash Slash _ -> model","title":"Keymap"},{"location":"slasher/#placing-a-backslash","text":"place : Cell -> Model -> Model place cell ({ actors , grid } as model ) = let loc = activeCell actors . player in { model | grid = gridSet loc cell grid }","title":"Placing a (back)slash"},{"location":"slasher/#view","text":"scale : Int scale = config . scale fScale : Float fScale = toFloat scale viewCell : ( Int , Int ) -> Cell -> List ( Html Msg ) viewCell ( i , j ) c = case c of Slash -> [ line [ x1 ( String . fromInt ( scale * i + scale )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] BackSlash -> [ line [ x1 ( String . fromInt ( scale * i )) , y1 ( String . fromInt ( scale * j )) , x2 ( String . fromInt ( scale * i + scale )) , y2 ( String . fromInt ( scale * j + scale )) , class \"slash\" ] [] ] Empty -> [] formatPath : List ( Float , Float ) -> String formatPath pts = case pts of [] -> \"\" ( x , y ) :: rest -> ( String . fromFloat <| x * fScale ) ++ \",\" ++ ( String . fromFloat <| y * fScale ) ++ \" \" ++ formatPath rest viewHero : Actor -> Html Msg viewHero actor = let ( x , y ) = actor . location path = case actorDirection actor of South -> [ ( x , y ) , ( x + 0. 3 , y - 1 ) , ( x - 0. 3 , y - 1 ) ] North -> [ ( x , y ) , ( x + 0. 3 , y + 1 ) , ( x - 0. 3 , y + 1 ) ] West -> [ ( x , y ) , ( x + 1 , y + 0. 3 ) , ( x + 1 , y - 0. 3 ) ] East -> [ ( x , y ) , ( x - 1 , y + 0. 3 ) , ( x - 1 , y - 0. 3 ) ] in polygon [ points <| formatPath path , class \"hero\" ] [] viewSnitch : Actor -> Html Msg viewSnitch actor = let ( x , y ) = actor . location in circle [ cx ( String . fromFloat <| x * fScale ) , cy ( String . fromFloat <| y * fScale ) , r ( String . fromInt <| scale // 2 ) , class \"snitch\" ] [] viewOverlay : GameState -> Html Msg viewOverlay state = let ( w , h ) = config . gridSize sWidth = ( String . fromInt <| config . scale * w ) sHeight = ( String . fromInt <| config . scale * h ) middleX = ( String . fromInt <| config . scale * w // 2 ) middleY = ( String . fromInt <| config . scale * h // 2 ) rectA = rect [ x \"0\" , y \"0\" , width sWidth , height sHeight , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , style \"fill: black\" ] [] textA s = text_ [ x middleX , y middleY , textAnchor \"middle\" ] [ text s ] overlay s = g [ id \"overlay\" ] [ rectA , textA s ] in case state of Running -> g [] [] Won -> overlay \"YOU WIN!\" Start -> overlay \"press space to start\" Pause -> overlay \"PAUSE\" viewSnitchBar : Float -> Html Msg viewSnitchBar t = let u = t / config . snitchTime ( w , h ) = config . gridSize sWidth = String . fromFloat <| ( toFloat w ) * u * ( toFloat config . scale ) in rect [ x \"0\" , y ( String . fromInt <| h * config . scale + 10 ) , width sWidth , height ( String . fromInt <| config . scale // 2 ) , id \"snitch-bar\" ] [] viewArena : Model -> Html Msg viewArena ({ actors , grid , state , snitchTime } as model ) = let blurAtPause = class <| if state == Running then \"non-blurred\" else \"blurred\" in svg [ width \"100%\" , viewBox ( \"-3 -3 \" ++ ( String . fromInt <| scale * 80 + 4 ) ++ \" \" ++ ( String . fromInt <| scale * 50 + 24 ))] [ g [] [ rect [ x \"0\" , y \"0\" , width ( String . fromInt ( scale * 80 )) , height ( String . fromInt ( scale * 50 )) , rx ( String . fromInt <| scale ) , ry ( String . fromInt <| scale ) , id \"box\" ] []] , g [ blurAtPause ] ( concat ( toList ( indexedMap ( \\ y rows -> ( concat ( toList ( indexedMap ( \\ x cell -> viewCell ( x , y ) cell ) rows )))) grid ))) , g [ blurAtPause ] [ viewHero actors . player , viewSnitch actors . snitch ] , ( viewOverlay state ) , ( viewSnitchBar snitchTime ) ] view : Model -> Html Msg view model = main_ [] [ div [ id \"header\" ] [ text \" \\\\ \\\\ S L A S H E R / /\" ] , div [ id \"arena\" ] [ viewArena model ] , div [ id \"help\" ] [ text \"keys: Left \\\\ | Right / | Space pause\" ] , div [ id \"footer\" ] [ text \"Use the source, at \" , a [ href \"https://entangled.github.io/\" ] [ text \"Entangled!\" ] ] ]","title":"View"},{"location":"slasher/#completing-the-game","text":"From the code we can either build a HTML or a JavaScript file for embedding. We will manually create the HTML so that we can also create a stylesheet. Here's the Makefile for creating an optimized and uglified version of slasher (you can install uglifyjs with npm install -g uglify-js ): .PHONY : build build : slasher . min . js slasher.js : src / Main . elm elm make src/Main.elm --output = slasher.js --optimize slasher.min.js : slasher . js uglifyjs slasher.js --compress 'pure_funcs=\"F2,F3,F4,F5,F6,F7,F8,F9,A2,A3,A4,A5,A6,A7,A8,A9\",pure_getters,keep_fargs=false,unsafe_comps,unsafe' | uglifyjs --mangle --output = slasher.min.js The HTML can be very short now: <!DOCTYPE html> < html > < head > < title > Slasher </ title > < meta charset = \"UTF-8\" > < < google-font > > < link rel = \"stylesheet\" href = \"css/slasher.css\" > </ head > < body > < div id = \"slasher\" ></ div > < script src = \"js/slasher.min.js\" ></ script > < script > Elm . Main . init ({ node : document . getElementById ( \"slasher\" ) }); </ script > </ body > </ html > Browse Google fonts for a nice slashery font: < link href = \"https://fonts.googleapis.com/css?family=Love+Ya+Like+A+Sister\" rel = \"stylesheet\" > And add some style body { font-family : \"Love Ya Like A Sister\" , sans serif ; background-image : radial-gradient ( circle , #112233 , #000033 ); color : white ; } # arena svg { max-height : 80 vh ; } # header { font-size : 20 pt ; text-align : center ; margin-bottom : 5 pt ; } # help { text-align : center ; } # footer { font-family : sans serif ; font-size : 8 pt ; background : #ffffff 44 ; color : black ; text-align : center ; padding : 4 pt 0 ; margin : 10 pt 0 0 0 ; border-radius : 5 pt ; } # footer a { color : #202 ; } . blurred { filter : blur ( 1 pt ); } /* svg #overlay { filter: blur(1pt); } */ svg # overlay rect { opacity : 0.3 ; fill : black ; } svg # overlay text { font-size : 70 pt ; fill : white ; } svg # box { opacity : 0.5 ; stroke : goldenrod ; stroke-width : 2 pt ; fill : none ; } svg line . slash { stroke : #8888ff ; stroke-width : 2 pt ; } svg . hero { fill : red ; stroke : black ; } svg . snitch { fill : gold ; stroke : black ; } svg # snitch-bar { opacity : 0.8 ; fill : gold ; stroke : black ; }","title":"Completing the game"},{"location":"syntax_experiments/","text":"Welcome to MkDocs \u00b6 For full documentation visit mkdocs.org . Commands \u00b6 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. code example entangled syntax \u00b6 spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } code example braces syntax \u00b6 spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } Code example space syntax with title so \u00b6 must support code highlighthing id and title file://thisShouldBreak.py let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" } Code example space syntax \u00b6 must support code highlighthing id and title haskell file=\"this should break.py\" title=\"spacedSyntax\" let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]* [[:alpha:]]+\" , matchCodeEnd = \"^[ ] \" , extractLanguage = \" ([[:alpha:]]+)\" , extractReferenceName = \" [[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \" [[:alpha:]]+[ ]+. file=\\\"([^\\\"] )\\\". \" } ```","title":"Experiments"},{"location":"syntax_experiments/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"syntax_experiments/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"syntax_experiments/#code-example-entangled-syntax","text":"spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"code example entangled syntax"},{"location":"syntax_experiments/#code-example-braces-syntax","text":"spacedSyntax let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"code example braces syntax"},{"location":"syntax_experiments/#code-example-space-syntax-with-title-so","text":"must support code highlighthing id and title file://thisShouldBreak.py let syntax : entangled . Syntax = { matchCodeStart = \"^[ ]*```[[:alpha:]]+\" , matchCodeEnd = \"^[ ]*```\" , extractLanguage = \"```([[:alpha:]]+)\" , extractReferenceName = \"```[[:alpha:]]+[ ]+.*id= \\\" ([^ \\\" ]*) \\\" .*\" , extractFileName = \"```[[:alpha:]]+[ ]+.*file= \\\" ([^ \\\" ]*) \\\" .*\" }","title":"Code example space syntax with title so"},{"location":"syntax_experiments/#code-example-space-syntax","text":"must support code highlighthing id and title haskell file=\"this should break.py\" title=\"spacedSyntax\" let syntax : entangled.Syntax = { matchCodeStart = \"^[ ]* [[:alpha:]]+\" , matchCodeEnd = \"^[ ] \" , extractLanguage = \" ([[:alpha:]]+)\" , extractReferenceName = \" [[:alpha:]]+[ ]+.*id=\\\"([^\\\"]*)\\\".*\" , extractFileName = \" [[:alpha:]]+[ ]+. file=\\\"([^\\\"] )\\\". \" } ```","title":"Code example space syntax"}]}